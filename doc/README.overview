The SHMEM development area is split up as follows:

    SHMEM
    |
    |-- Makefile        build everything
    |-- make.include    common make settings for sub-directories
    |-- doc             this README and other things
    |-- examples        test and demo programs
    `-- src             source of SHMEM library

-------------------------------------------------------------------------

Implementation:

The library has an abstraction layer so we can plug in other
communication libraries, such as ARMCI, in place of GASNet.

                  GASNet                           Abstracted
        
         +=======================+          +=======================+
         |                       |          |       SHMEM API       |
         |       SHMEM API       |          +-----------------------+
         |                       |          |    SHMEM Internal     |
         +-----------------------+          +-----------------------+
         |        GASNet         |          | GASNet | ARMCI | ...  |
         +=======================+          +=======================+

Functions/variables whose names start with "__" are
implementation-internal and are not part of the API.  The API is
defined in shmem.{h,fh}.

To see things that aren't done, but I know need to be done, do a

    grep -R -n 'TODO:' from the top-level directory.

-------------------------------------------------------------------------

Initialization:

In src/updown.c we handle setting up the SHMEM runtime, and eventual
shutdown.  Shutdown is implicit in user code, there is no call to do
this, so we have to register a handler to be called when main() exits.

GASNet provides the symmetric memory areas.  The dlmalloc library
provides management of these areas during allocation and freeing of
symmetric variables in user code, usually through a call like
shmalloc().

When you GASNet-attach and ask for segment information, each PE has
access to an array of segments, 1 segment per PE.  Each PE initializes
a memory pool within its own segment.  The set up is handled either by
GASNet internally ("fast"/"large" model) or by SHMEM ("everything"
model).

If the platform allows it, GASNet can align all the segments at the
same address, which means that all PEs see the same address for
symmetric variables and there's no address translation.

In the general case though, segments are not aligned (e.g. due to a
security measure like process address space randomization by the OS).
However, each PE can see the addresses of the segments of the other
PEs locally, and can therefore do address translation.

Currently alignment is not checked for, so we're coding to the "worst
case scenario".  That just adds a *small* overhead if the segments are
in fact aligned.  The library should at some point introduce code that
differentiates between aligned and non-aligned environments with
optimized code for the former case (GASNet provides a macro you can
test against).

-------------------------------------------------------------------------

Starting SHMEM:

We provide both the SGI start_pes(int n) and shmem_init(void)
interfaces.  The parameter to start_pes is completely ignored
(consistent with SGI behavior).

-------------------------------------------------------------------------

Symmetric Memory:

Using the dlmalloc library:

  http://gee.cs.oswego.edu/dl/html/malloc.html

Seems to have fixed up all the bizarre problems I was seeing with the
TLSF library (used in the SiCortex implementation).  I think (from
valgrind analysis) the issues were related to OpenMPI intercepting
malloc-related calls.

-------------------------------------------------------------------------

Put/Get:

In src/putget.c we manage the simple shmem_<type>_put and get
routines.  I've included a short-circuit check for local-local
transfers, and a trap to detect attempted use of non-symmetric
variables in the wrong place could be useful too.

Using the GASNet "everything" model, I can now put to both classes of
data.  Code stubs in place for "fast"/"large" model but concentrating
on the "everything" setup to get things closer to completion.
Handling different cases is a nice addition.

Strided put/get just builds on the point put/gets.

-------------------------------------------------------------------------

Broadcast:

src/broadcast.c has a simple implementation of shmem_broadcast().  In
the future, expect to include more scalable versions
(e.g. tree-based), and potentially allow runtime (or launchtime)
choice of algorithm.

-------------------------------------------------------------------------

Barrier:

src/barrier.c and src/comms.c have a simple implementation of
shmem_barrier().  In the future, expect to include more scalable
versions (e.g. tree-based), and potentially allow runtime (or
launchtime) choice of algorithm.

-------------------------------------------------------------------------

Collects:

src/fcollect.c and src/collect.c implement the collector routines
(concatenating arrays on a set of PEs into a target array on all of
those PEs).

fcollect is pretty easy since all the PEs must contribute the same
amount of data.  This means we can just pre-compute where each PE
writes to their targets.

collect is harder because each PE can write different amounts.
Thought of 2 ways of handling this:

1. initial exchange of sizes "from the left" so each PE can compute
its write locations; then same as fcollect

2. wavefront: PEs wait for notification from PEs before them in the
set (lower numbered).  This passes the offsets across the set.

I used #2.  #1 potentially generates a network storm as all PEs wait
to work out where to write, then all go mad.  #2 staggers the offset
notification with a wave of writes moving up the PE numbers.

-------------------------------------------------------------------------

Reductions:

Still getting my head around how best to do these.  Basically what the
shmem_<type>_<op>_to_all routines do is take a slice of a source array
of indexes 0 .. n-1, and then do

  target[0]     = map <op>   source[0] @ each PE in active set
  target[1]     = map <op>   source[1] @ each PE in active set
  ...
  target[n-1]   = map <op> source[n-1] @ each PE in active set

  on all PEs

-------------------------------------------------------------------------

API Header File:

src/shmem.h (and .fh) are the public APIs and installed into the
target include directory.  Currently written by hand, should probably
be generated from per-module headers, e.g. by marking API symbols as
"public" or similar.  Have set up both <shmem.h> and <mpp/shmem.h> so
that we're both SGI-conformant and friendly to other SHMEM versions.

-------------------------------------------------------------------------

Swaps:

Done with Active Messages.
