#LyX 1.6.8 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
OpenSHMEM Reference Library Implementation
\end_layout

\begin_layout Author
Tony Curtis and Swaroop Pophale
\end_layout

\begin_layout Right Address
Computer Science Department, University of Houston
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Sponsorship
\end_layout

\begin_layout Standard
Work on the OpenSHMEM project is sponsored by Oak Ridge National Laboratory
 and the U.S.
 Department of Defense.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This document is an overview of the implementation strategy for the initial,
 reference version of what will become OpenSMHEM.
 We will discuss the concept of a partitioned global address space for completen
ess.
\end_layout

\begin_layout Section
Terminology
\end_layout

\begin_layout Standard
A SHMEM program consists of a number of processors executing separate processes.
 A processor is referred to as a 
\begin_inset Quotes eld
\end_inset

processing element
\begin_inset Quotes erd
\end_inset

, or PE.
 All PEs run the same program in the SPMD model, although they can discover
 which position, or rank, they occupy within the program and diverge in
 behavior.
\end_layout

\begin_layout Standard
The number of PEs participating in the program is set at launch-time (although
 not all PEs need to do work).
 PEs are numbered monotonically increasing from 0 up to N-1, where N is
 the total number of PEs.
 PEs are assumed to be equidistant from each other for communication purposes,
 no topological information is currently exposed.
\end_layout

\begin_layout Standard
Communication occurs through point-to-point one-sided routines and collective
 operations.
 A one-sided operation is a communication in which one PE transfers data
 to another PE, but the 
\begin_inset Quotes eld
\end_inset

other
\begin_inset Quotes erd
\end_inset

 PE does not participate: the data transfer does not cause the other PE
 to be interrupted to acknowledge the transfer.
\end_layout

\begin_layout Section
Partitioned Global Address Space
\end_layout

\begin_layout Standard
Parallel programs running in a distributed environment access both local
 and remote data.
 The model used to construct the program can either expose or hide this
 distribution.
 Exposed models include that of MPI and PVM, in which explicit messages
 are required to pass data between processors participating in a parallel
 program.
 Hidden models include those with a Global Address Space (GAS), in which
 there appears to be memory accessible from all processors.
 This memory may be physically accessible, or may in fact be made available
 through I/O operations over network interconnects.
\end_layout

\begin_layout Standard
SHMEM provides a symmetric view of memory, in which processors allocate
 variables in concert but have their own copies.
 A processor can then 
\begin_inset Quotes eld
\end_inset

put
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

get
\begin_inset Quotes erd
\end_inset

 data to or from other processors by requesting a specific variable on another
 processor.
 SHMEM provides for address translation when required to allow a variable
 allocated by one processor to be accessed by another, because in a number
 of environments it is not guaranteed that address spaces are uniform.
 This allocation-in-concert of separate variables is termed Partitioned
 Global Address Space (PGAS).
\end_layout

\begin_layout Standard
Clusers that use interconnects with remote direct memory access (rDMA) are
 of particular interest to the PGAS community as they provide hardware off-load
 capability to avoid interrupts during one-sided communications.
\end_layout

\begin_layout Section
SHMEM History and OpenSHMEM
\end_layout

\begin_layout Standard
The SHMEM communications library was originally developed as a proprietary
 application interface by Cray for their T3D systems and subsequently the
 T3E models.
 These systems typically consisted of a memory subsystem with a logically
 shared address space over physically distributed memories, a memory interconnec
t network, a set of processing elements (PEs), a set of input-output gateways,
 and a host subsystem.
 The systems were designed to support latency hiding mechanisms such as
 prefetch queues, remote stores and the Block Transfer Engine (BLT).
 The prefetch queues allowed the users to issue multiple asynchronous single-wor
d reads which could overlap with computation.
 Remote stores enabled PEs to directly write to other PE's memory asynchronously
, while the BLT could hide latency while transferring blocks of data efficiently
 between local memory and remote memory locations.
 The explicit shared memory programming method allowed strucured communication
 via shared memory on Cray MPP systems.
 
\end_layout

\begin_layout Standard
Since then different vendors have come up with variations of the SHMEM library
 implementation to match their individual requirements.
 By adding proprietary hardware support some vendors have managed to make
 the communication faster but have sacrificed portability.
 Some existing SHMEM implementations include those by Cray, Quadrics’ QsNet,
 SGI’s versions for their IRIX and Altix platforms, HP, IBM and those that
 were developed for the SiCortex platforms, and the more portable but older
 GPSHMEM.
 These implementations have over the years diverged because of the lack
 of a standard specification.
 We aim to form a community that will unify all SHMEM library development
 effort and lead to the formulation of a standardized library to be called
 OpenSHMEM.
 OpenSHMEM will be a community-driven, open process.
\end_layout

\begin_layout Section
The SHMEM Library
\end_layout

\begin_layout Standard
The overall structure of the reference library is shown below.
 We use an intermediate library such as GASNet or ARMCI to abstract away
 from a particular interconnect/platform, although there is nothing to stop
 a more direct approach being used.
 Internally, SHMEM provides private APIs for memory management, the communicatio
ns layer, tracing/debugging and (eventually) support for adaptivity to choose
 things like barrier algorithm at run-time.
\end_layout

\begin_layout Title
\begin_inset Graphics
	filename Slide17.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Section
Implementation Strategy
\end_layout

\begin_layout Standard
In this section we talk about how the library was written and why certain
 implementation strategies were chosen.
\end_layout

\begin_layout Subsection
GASNet
\end_layout

\begin_layout Standard
GASNet provides the symmetric memory areas.
 A memory management library marshalls accesses to these areas during allocation
 and freeing of symmetric variables in user code, usually through a call
 like 
\family typewriter
shmalloc()
\family default
.
\end_layout

\begin_layout Standard
When you 
\family typewriter
gasnet_attach()
\family default
 and ask for segment information, each PE has access to an array of segments,
 1 segment per PE.
 Each PE initializes a memory pool within its own segment.
 The set up is handled either by GASNet internally (
\begin_inset Quotes eld
\end_inset

fast
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

large
\begin_inset Quotes erd
\end_inset

 model) or by SHMEM itself (
\begin_inset Quotes eld
\end_inset

everything
\begin_inset Quotes erd
\end_inset

 model).
 The table of segments allows any PE to know the virtual location and size
 of the segment belonging to any other PE.
\end_layout

\begin_layout Standard
If the platform allows it, GASNet can align all the segments at the same
 address, which means that all PEs see the same address for symmetric variables
 and there's no address translation.
\end_layout

\begin_layout Standard
In the general case though, segments are not aligned (e.g.
 due to a security measure like process address space randomization by the
 OS).
 However, each PE can see the addresses of the segments of the other PEs
 locally, and can therefore do address translation.
\end_layout

\begin_layout Standard
Currently alignment is not checked for, so we're coding to the 
\begin_inset Quotes eld
\end_inset

worst case scenario
\begin_inset Quotes erd
\end_inset

.
 That just adds a 
\emph on
small
\emph default
 overhead if the segments are in fact aligned.
 The library should at some point introduce code that differentiates between
 aligned and non-aligned environments with optimized code for the former
 case (GASNet provides a macro you can test against).
\end_layout

\begin_layout Subsection
Initialization
\end_layout

\begin_layout Standard
In 
\family typewriter
src/updown.c
\family default
 we handle setting up the SHMEM runtime, and eventual shutdown.
 Shutdown is implicit in user code, there is no call to do this in SGI SHMEM,
 so we register a handler to be called when 
\family typewriter
main()
\family default
 exits.
 (Cray SHMEM has an explicit finalize call, however.) The segment exchange
 is a target for future optimization: in large programs, the start-up time
 will become burdensome due to the large number of address/size communication.
 Strategies for avoiding this include lazy initialization and hierarchical
 lookups.
\end_layout

\begin_layout Subsection
Incorporating SHMEM into Programs
\end_layout

\begin_layout Standard
For C, the appropriate header file must be included: both the SGI-compliant
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include <mpp/shmem.h>
\end_layout

\end_inset

and the Quadrics-like
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include <shmem.h>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
are handled for portability.
 We provide both the SGI
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

start_pes(int npes)
\end_layout

\end_inset

 and
\end_layout

\begin_layout Standard
\align left
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

shmem_init(void)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
interfaces, again for portability.
 The calls are synonyms.
 
\family typewriter
start_pes()
\family default
 just ignores its argument (consistent with SGI behavior.
 SGI indicates 
\begin_inset Quotes eld
\end_inset

npes
\begin_inset Quotes erd
\end_inset

 
\emph on
should
\emph default
 be set to zero but we don't enforce that, merely note it).
 The number of PEs is taken from the invoking environment.
 Currently this number is assumed to be fixed throughout the lifetime of
 the program, but fault tolerance extensions could generalize this notion.
\end_layout

\begin_layout Subsection
Communications Substrate
\end_layout

\begin_layout Standard
The OpenSHMEM library has been written to sit on top of any communications
 library that can provide the required functionalty.
 Initially we have targetted GASNet, and an ARMCI version is also planned.
 The file 
\family typewriter
trunk/src/comms.c
\family default
 provides the internal API.
 All subsequent references to GASNet should be read with an eye on the abstracti
on process.
\end_layout

\begin_layout Subsection
Servicing Communications
\end_layout

\begin_layout Standard
A separate service thread handles network traffic.
 Waits and spins on variables yield to the service thread which is just
 a continuous poll on the communication layer.
 The initialization phase creates the service thread and the registered
 shutdown handler turns off the thread.
 If the 
\begin_inset Quotes eld
\end_inset

mainline
\begin_inset Quotes erd
\end_inset

 sleeps or otherwise can't handle communication, this thread takes up the
 work.
 It's meant to look like the way dedicated hardware solutions do this kind
 of thing.
 A routine provides the ability to send requests to the service thread.
 This is how 
\family typewriter
shmem_quiet()
\family default
 is handled: we tell the service thread to wait for pending I/O.
\end_layout

\begin_layout Subsection
Memory Management
\end_layout

\begin_layout Standard
Initially we tried to use the TLSF library:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://rtportal.upv.es/rtmalloc/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
but this proved to have weird interactions with Open-MPI.
 Tracking program progress with valgrind suggested that system memory calls
 were being intercepted.
\end_layout

\begin_layout Standard
So, following the Chapel lead,
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://chapel.cray.com/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
we now use the 
\begin_inset Quotes eld
\end_inset

dlmalloc
\begin_inset Quotes erd
\end_inset

 library
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://g.oswego.edu/dl/html/malloc.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to manage allocations in the symmetric memory space.
\end_layout

\begin_layout Subsection
Point-to-point routines
\end_layout

\begin_layout Standard
Point-to-point operations are a thin layer on top of GASNet.
 The non-blocking put operations with implicit handles provide a way to
 subsequently fence and barrier.
 However, tracking individual handles explicitly with a hash table keyed
 on the address of symmetric variables may give better performance.
\end_layout

\begin_layout Standard
The Quadrics extensions that add non-blocking calls into the API proper
 have already been requested for the OpenSHMEM development.
\end_layout

\begin_layout Subsection
Atomic Operations
\end_layout

\begin_layout Standard
Atomic operations include swaps, fetch-and-add and locks.
 The first two are handled via GASNet's Active Messages.
 Increment was originally layered on top of add (increment = add 1, after
 all) but was rewritten with its own handlers.
 The payload for increment is ever so slightly smaller than for add since
 there's no need to pass the value to add.
 In large applications, even such a small saving could add up (if you'll
 pardon the pun).
\end_layout

\begin_layout Standard
The current implementation has a single handler lock variable per operation
 (add, increment, 
\emph on
etc.
\emph default
).
 However, allocating and managing a separate lock variable for each remotely
 accessed address might scale better to large systems.
\end_layout

\begin_layout Subsection
Locks
\end_layout

\begin_layout Standard
SHMEM provides routines to claim, release and test global locks.
 These can be used for mutual-exclusion regions.
 Our implementation is from the Quadrics library, which is a version of
 the Mellor-Crummy-Scott algorithm (
\begin_inset Quotes eld
\end_inset

Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors
\begin_inset Quotes erd
\end_inset

 by John M.
 Mellor-Crummey and Michael L Scott).
 The locks are layered on top of SHMEM primitives, so there are no Elan
 dependencies.
\end_layout

\begin_layout Subsection
Broadcast
\end_layout

\begin_layout Standard
The initial version is naive, making the root of the broadcast a bottleneck.
 This is partly intentional, to allow Swaroop to explore better algorithms
 and work out how to demonstrate and document the improvements.
 We would like to collect some locality information inside the library to
 help decide communication order inside these algorithms: PEs that differ
 in rank by large amounts are likely to be further away topologically too,
 so by sending to more distant PEs first, we can stagger the network traffic
 and balance the latencies better.
 A proper measurement of 
\begin_inset Quotes eld
\end_inset

distance
\begin_inset Quotes erd
\end_inset

 is needed here.
 
\begin_inset Quotes eld
\end_inset

hwloc
\begin_inset Quotes erd
\end_inset

 provides a per-system distance metric in NUMA terms.
 A simple extension could 
\emph on
e.g.

\emph default
 just multiply the distance by some constant when moving off-node to penalize
 network traffic.
\end_layout

\begin_layout Subsection
Collects
\end_layout

\begin_layout Standard
The files 
\family typewriter
src/fcollect.c
\family default
 and 
\family typewriter
src/collect.c
\family default
 implement the collector routines (concatenating arrays on a set of PEs
 into a target array on all of those PEs).
\end_layout

\begin_layout Standard
fcollect is pretty easy since all the PEs must contribute the same amount
 of data.
 This means we can just pre-compute where each PE writes to their targets.
\end_layout

\begin_layout Standard
collect is harder because each PE can write different amounts.
 Thought of 2 ways of handling this:
\end_layout

\begin_layout Enumerate
initial exchange of sizes 
\begin_inset Quotes eld
\end_inset

from the left
\begin_inset Quotes erd
\end_inset

 so each PE can compute its write locations; then same as fcollect
\end_layout

\begin_layout Enumerate
wavefront: PEs wait for notification from PEs before them in the set (lower
 numbered).
 This passes the offsets across the set.
\end_layout

\begin_layout Standard
I used #2.
 #1 potentially generates a network storm as all PEs wait to work out where
 to write, then all write at once.
 #2 staggers the offset notification with a wave of writes moving up the
 PE numbers.
 
\end_layout

\begin_layout Subsection
Reductions
\end_layout

\begin_layout Standard
Reductions coalesce data from a number of PEs into either a single variable
 or array on all participating PEs.
 The coalescing involves some kind of arithmetic or logic operation (e.g.
 sum, product, exclusive-or).
 Currently probably naive, using gets.
 A version with puts that can overlap communication and the computation
 of the reduction operation should be more scalable.
 However, the code is rather compact and all ops use the same template.
\end_layout

\begin_layout Subsection
Accessibility
\end_layout

\begin_layout Standard
SHMEM allows us to test whether PEs are currently reachable, and whether
 addresses on remote PEs are addressable.
 GASNet is used to 
\begin_inset Quotes eld
\end_inset

ping
\begin_inset Quotes erd
\end_inset

 the remote PE and then we wait for an 
\begin_inset Quotes eld
\end_inset

ack
\begin_inset Quotes erd
\end_inset

 with a configurable timeout.
 Remains to be seen how useful this is, and whether it can be used for future
 fault tolerance issues.
\end_layout

\begin_layout Subsection
Tracing Facility
\end_layout

\begin_layout Standard
This library contains “trace points” with categorized messages.
 These are listed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Environment-Variables"

\end_inset


\end_layout

\begin_layout Standard
A high-resolution clock is maintained to timestamp such messages.
 Numerically sorting the output on the first field can thus help understand
 the order in which events happened.
\end_layout

\begin_layout Section
Undefined Behavior
\end_layout

\begin_layout Standard
Many routines are currently specified only in terms of 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 behavior.
 What happens when something goes wrong is not always specified.
 This section attempts to set out a few of these scenarios
\end_layout

\begin_layout Itemize
put to PE out of range: suppose we do a put to 
\begin_inset Quotes eld
\end_inset

right neighbor
\begin_inset Quotes erd
\end_inset

 (pe + 1).
 The highest-numbered PE will attempt to communicate with a PE that does
 not exist.
\end_layout

\begin_layout Itemize
library not initialized: virtually all SHMEM routines will have major problems
 if the library has not been initialized.
 Implementations can handle this situation in different ways.
\end_layout

\begin_layout Section
Environment Variables
\begin_inset CommandInset label
LatexCommand label
name "sec:Environment-Variables"

\end_inset


\end_layout

\begin_layout Standard
The behavior of the OpenSHMEM library can be controlled via a number of
 environment variables.
 For SGI compatibility reasons, we support the 
\begin_inset Quotes eld
\end_inset

SMA
\begin_inset Quotes erd
\end_inset

 variables and our own new ones.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SMA_VERSION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
print the library version at start-up
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SMA_INFO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
print helpful text about all these environment variables
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SMA_SYMMETRIC_SIZE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
number of bytes to allocate for symmetric heap
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SMA_DEBUG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
enable debugging messages
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_LOG_LEVELS
\family default
: a comma, space, or semi-colon separated list of logging/trace facilities
 to enable debugging messages.
 The facilities currently include the case-insensitive names:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Facility
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meaning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DEBUG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
used for debugging purposes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INFO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
something interesting happened
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NOTICE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
important event, but non-fatal (see below)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AUTH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when something is attempted but not allowed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INIT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
set-up and tear-down of the program
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MEMORY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
symmetric memory information
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CACHE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cache flushing operations
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BARRIER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
about barrier operations
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BROADCAST
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
about broadcast operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
COLLECT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
about collect and fcollect operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
REDUCE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
about reduction operations
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SYMBOLS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
to inspect the symbol table information
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOCK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
related to setting, testing and clearing locks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SERVICE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
related to the network service thread
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FATAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
something unrecoverable happened, abort
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_LOG_FILE
\family default
: a filename to which to write log messages.
 All PEs append to this file.
 The default is for all PEs to write to standard error.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_SYMMETRIC_HEAPSIZE
\family default
: the number of bytes to allocate for the symmetric heap area.
 Can scale units with 
\begin_inset Quotes eld
\end_inset

K
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

M
\begin_inset Quotes erd
\end_inset

 etc.
 modifiers.
 The default is 1M.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_BARRIER_ALGORITHM
\family default
: the version of the barrier to use.
 The default is 
\begin_inset Quotes eld
\end_inset

naive
\begin_inset Quotes erd
\end_inset

.
 Designed to allow people to plug other variants in easily and test.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_BARRIER_ALL_ALGORITHM
\family default
: as for 
\family typewriter
SHMEM_BARRIER_ALGORITHM
\family default
, but separating these two allows us to optimize if e.g.
 hardware has special support for global barriers.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_PE_ACCESSIBLE_TIMEOUT
\family default
: the number of seconds to wait for PEs to reply to accessiblity checks.
 The default is 1.0 (i.e may be fractional).
\end_layout

\begin_layout Section
Compiling and Running Programs
\end_layout

\begin_layout Standard
The SGI SHMEM is provided as part of the Message-Passing Toolkit (MPT) in
 the 
\begin_inset CommandInset href
LatexCommand href
name "ProPack"
target "http://www.sgi.com/products/software/propack.html"

\end_inset

 suite.
 Compilation uses a standard C, C++ or Fortran compiler (
\emph on
e.g.

\emph default
 GNU, Intel) and links against the SMA and MPI libraries.
\end_layout

\begin_layout Standard
In order to abstract the compilation and launching process for OpenSHMEM
 we have provided 4 wrapper programs:
\end_layout

\begin_layout Enumerate

\family typewriter
oshcc
\family default
: for compiling and linking C programs.
\end_layout

\begin_layout Enumerate

\family typewriter
oshCC
\family default
: for compiling and linking C++ programs.
\end_layout

\begin_layout Enumerate

\family typewriter
oshfort
\family default
: for compiling and linking F77/F90 programs.
\end_layout

\begin_layout Enumerate

\family typewriter
oshrun
\family default
: to launch programs.
\end_layout

\begin_layout Standard
The similarity to the style of wrappers found in many MPI implementations
 is obvious and intentional.
 Currently these wrappers do handle a few situations (e.g.
 oshcc/CC and oshfort detect that they shouldn't do linking and stop the
 underlying compiler complaining about link options being present, but unused).
 The compiler scripts are generated from a common template.
\end_layout

\begin_layout Section
Configuration and Installation
\end_layout

\begin_layout Standard
There is a 
\family typewriter
trunk/configure
\family default
 script that is a simplified version of the GNU autotools.
 This script will eventually become the GNU setup and will do lots more
 feature tests.
 So the usual procedure applies: configure, make, make install.
\end_layout

\begin_layout Section
Future Plans
\end_layout

\begin_layout Standard
Ideas for extensions to SHMEM to go into OpenSHMEM need to be requested
 and evaluated from the SHMEM user and vendor community.
 A decision process will determine which ideas are eventually implemented.
 The library that this document refers to is hopefully a good platform for
 these developments.
\end_layout

\end_body
\end_document
