#LyX 1.6.8 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
OpenSHMEM Reference Library Implementation
\end_layout

\begin_layout Author
Tony Curtis
\begin_inset Foot
status open

\begin_layout Plain Layout
Email address: arcurtis@mail.uh.edu
\end_layout

\end_inset


\end_layout

\begin_layout Right Address
Computer Science Department, University of Houston
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Sponsorship
\end_layout

\begin_layout Standard
Work on the OpenSHMEM project is sponsored by the 
\begin_inset CommandInset href
LatexCommand href
name "Oak Ridge National Laboratory"
target "http://www.ornl.gov/"

\end_inset

 Extreme Scale System Center and the 
\begin_inset CommandInset href
LatexCommand href
name "U.S. Department of Defense"
target "http://www.dod.gov/"

\end_inset

.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This document is an overview of the implementation strategy for the initial,
 reference version of what will become OpenSMHEM.
 We will discuss the concept of a partitioned global address space for completen
ess.
\end_layout

\begin_layout Section
Terminology
\end_layout

\begin_layout Standard
A SHMEM program consists of a number of processors executing separate processes.
 A processor is referred to as a 
\begin_inset Quotes eld
\end_inset

processing element
\begin_inset Quotes erd
\end_inset

, or PE.
 All PEs run the same program in the SPMD model, although they can discover
 which position, or rank, they occupy within the program and diverge in
 behavior.
\end_layout

\begin_layout Standard
The number of PEs participating in the program is set at launch-time (although
 not all PEs need to do work).
 PEs are numbered monotonically increasing from 0 up to 
\begin_inset Formula $N-1$
\end_inset

, where N is the total number of PEs.
 PEs are assumed to be equidistant from each other for communication purposes,
 no topological information is currently exposed.
\end_layout

\begin_layout Standard
Communication occurs through point-to-point one-sided routines and collective
 operations.
 A one-sided operation is a communication in which one PE transfers data
 to another PE, but the 
\begin_inset Quotes eld
\end_inset

other
\begin_inset Quotes erd
\end_inset

 PE does not participate: the data transfer does not cause the other PE
 to be interrupted to acknowledge the transfer.
\end_layout

\begin_layout Section
Partitioned Global Address Space
\end_layout

\begin_layout Standard
Parallel programs running in a distributed environment access both local
 and remote data.
 The model used to construct the program can either expose or hide this
 distribution.
 Exposed models include that of MPI and PVM, in which explicit messages
 are required to pass data between processors participating in a parallel
 program.
 Hidden models include those with a Global Address Space (GAS), in which
 there appears to be memory accessible from all processors.
 This memory may be physically accessible, or may in fact be made available
 through I/O operations over network interconnects.
\end_layout

\begin_layout Standard
SHMEM provides a symmetric view of memory, in which processors allocate
 variables in concert but have their own copies.
 A processor can then 
\begin_inset Quotes eld
\end_inset

put
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

get
\begin_inset Quotes erd
\end_inset

 data to or from other processors by requesting a specific variable on another
 processor.
 SHMEM provides for address translation when required to allow a variable
 allocated by one processor to be accessed by another, because in a number
 of environments it is not guaranteed that address spaces are uniform.
 This allocation-in-concert of separate variables is termed Partitioned
 Global Address Space (PGAS).
\end_layout

\begin_layout Standard
Clusers that use interconnects with remote direct memory access (rDMA) are
 of particular interest to the PGAS community as they provide hardware off-load
 capability to avoid interrupts during one-sided communications.
\end_layout

\begin_layout Section
SHMEM History and OpenSHMEM
\end_layout

\begin_layout Standard
The SHMEM communications library was originally developed as a proprietary
 application interface by Cray for their T3D systems and subsequently the
 T3E models.
 These systems typically consisted of a memory subsystem with a logically
 shared address space over physically distributed memories, a memory interconnec
t network, a set of processing elements (PEs), a set of input-output gateways,
 and a host subsystem.
 The systems were designed to support latency hiding mechanisms such as
 prefetch queues, remote stores and the Block Transfer Engine (BLT).
 The prefetch queues allowed the users to issue multiple asynchronous single-wor
d reads which could overlap with computation.
 Remote stores enabled PEs to directly write to other PE's memory asynchronously
, while the BLT could hide latency while transferring blocks of data efficiently
 between local memory and remote memory locations.
 The explicit shared memory programming method allowed structured communication
 via shared memory on Cray MPP systems.
 
\end_layout

\begin_layout Standard
SHMEM was later adapted by SGI for its products based on the Numa-Link architect
ure and included in the Message Passing Toolkit (MPT).
 Other SHMEM implementations grew out of the SGI and Cray implementations,
 including Quadrics, HP, IBM, gpSHMEM and SiCortex, but diverged from the
 original libraries as they developed.
 These implementations of the SHMEM API support C, C++, and Fortran programs;
 however, the differences between SHMEM implementations' semantics and APIs
 are subtle, resulting in portability and correctness issues.
 U.S.
 Department of Defense funded a collaboration between Oak Ridge National
 Laboratory and the University of Houston to develop a specification for
 a uniform SHMEM API.
 The OpenSHMEM specification was announced to address the divergence of
 the SHMEM APIs.
 
\end_layout

\begin_layout Section
The Reference OpenSHMEM Library
\end_layout

\begin_layout Standard
The overall structure of the reference library is shown below.
 We use an intermediate library such as GASNet or ARMCI to abstract away
 from a particular interconnect/platform, although there is nothing to stop
 a more direct approach being used.
 Internally, the reference implementation of OpenSHMEM provides private
 APIs for memory management, the communications layer, tracing/debugging
 and (eventually) support for adaptivity to choose things like barrier algorithm
 at run-time.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Title
\begin_inset Graphics
	filename implementation.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Section
Implementation Strategy
\end_layout

\begin_layout Standard
In this section we talk about how the reference library was written and
 why certain implementation strategies were chosen.
\end_layout

\begin_layout Subsection
GASNet
\end_layout

\begin_layout Standard
GASNet provides access to the symmetric memory areas.
 A memory management library marshals accesses to these areas during allocation
 and freeing of symmetric variables in user code, usually through a call
 like 
\family typewriter
shmalloc()
\family default
.
\end_layout

\begin_layout Standard
When you 
\family typewriter
gasnet_attach()
\family default
 and ask for segment information, each PE has access to an array of segments,
 1 segment per PE.
 Each PE initializes a memory pool within its own segment.
 The set up is handled either by GASNet internally (
\begin_inset Quotes eld
\end_inset

fast
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

large
\begin_inset Quotes erd
\end_inset

 model) or by OpenSHMEM itself (
\begin_inset Quotes eld
\end_inset

everything
\begin_inset Quotes erd
\end_inset

 model).
 The table of segments allows any PE to know the virtual location and size
 of the segment belonging to any other PE.
\end_layout

\begin_layout Standard
If the platform allows it, GASNet can align all the segments at the same
 address, which means that all PEs see the same address for symmetric variables
 and there's no address translation.
\end_layout

\begin_layout Standard
In the general case though, segments are not aligned (e.g.
 due to a security measure like process address space randomization by the
 OS).
 However, each PE can see the addresses of the segments of the other PEs
 locally, and can therefore do address translation.
\end_layout

\begin_layout Standard
Currently alignment is not checked for, so we're coding to the 
\begin_inset Quotes eld
\end_inset

worst case scenario
\begin_inset Quotes erd
\end_inset

.
 That just adds a 
\emph on
small
\emph default
 overhead if the segments are in fact aligned.
 The library should at some point introduce code that differentiates between
 aligned and non-aligned environments with optimized code for the former
 case (GASNet provides a macro you can test against).
\end_layout

\begin_layout Subsubsection
Segment Models
\end_layout

\begin_layout Standard
The library currently has best support for the 
\begin_inset Quotes eld
\end_inset

everything
\begin_inset Quotes erd
\end_inset

 model.
 This model allows the entire process space to be addressed remotely.
 Communication with dynamically allocated data and with global data is equally
 easy.
\end_layout

\begin_layout Standard
For the 
\begin_inset Quotes eld
\end_inset

fast
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

large
\begin_inset Quotes erd
\end_inset

 models, only a specified area of the process memory is exposed for remote
 access.
 This means extra support has to be added to handle communication with global
 variables, because only the symmetric heap is exposed by GASNet.
 Currently this is done via Active Messages.
\end_layout

\begin_layout Standard
For the SMP conduit, PSHM support is required to run parallel threaded programs
 with OpenSHMEM.
 This excludes the 
\begin_inset Quotes eld
\end_inset

everything
\begin_inset Quotes erd
\end_inset

 model (at least for the architectures to hand).
\end_layout

\begin_layout Subsection
Initialization
\end_layout

\begin_layout Standard
In 
\family typewriter
src/updown.c
\family default
 we handle setting up the OpenSHMEM runtime, and eventual shutdown.
 Shutdown is implicit in user code, there is no call to do this in SGI SHMEM,
 so we register a handler to be called when 
\family typewriter
main()
\family default
 exits.
 (Cray SHMEM has an explicit finalize call, however.) The segment exchange
 is a target for future optimization: in large programs, the start-up time
 will become burdensome due to the large number of address/size communication.
 Strategies for avoiding this include lazy initialization and hierarchical
 lookups.
\end_layout

\begin_layout Subsection
Incorporating SHMEM into Programs
\end_layout

\begin_layout Standard
For C, the appropriate header file must be included: both the SGI-compliant
 
\family typewriter
<mpp/shmem.h>
\family default
 and the Quadrics-like 
\family typewriter
<shmem.h>
\family default
 are handled for portability.
 We provide both the SGI 
\family typewriter
start_pes(int npes)
\family default
 and 
\family typewriter
shmem_init(void)
\family default
 interfaces, again for portability.
 The calls are synonyms.
 
\family typewriter
start_pes()
\family default
 just ignores its argument (consistent with SGI behavior.
 SGI indicates 
\begin_inset Quotes eld
\end_inset

npes
\begin_inset Quotes erd
\end_inset

 
\emph on
should
\emph default
 be set to zero but we don't enforce that, merely note it).
 The number of PEs is taken from the invoking environment.
 Currently this number is assumed to be fixed throughout the lifetime of
 the program, but fault tolerance extensions could generalize this notion.
 Below are simple C and Fortran program templates:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <mpp/shmem.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int
\end_layout

\begin_layout Plain Layout

main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int me, npes;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  start_pes(0);
\end_layout

\begin_layout Plain Layout

  me = _my_pe();       /* which PE I am */
\end_layout

\begin_layout Plain Layout

  npes = _num_pes();   /* how many PEs in program */
\end_layout

\begin_layout Plain Layout

  printf("Hello from PE %d of %d
\backslash
n", me, npes);
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={[90]Fortran}"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

program hello
\end_layout

\begin_layout Plain Layout

  include 'mpp/shmem.fh'
\end_layout

\begin_layout Plain Layout

  integer me, npes
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  call start_pes(0)
\end_layout

\begin_layout Plain Layout

  me = my_pe()
\end_layout

\begin_layout Plain Layout

  npes = num_pes()
\end_layout

\begin_layout Plain Layout

  print *, 'Hello from PE ', me, ' of ', npes
\end_layout

\begin_layout Plain Layout

end program hello
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Communications Substrate
\end_layout

\begin_layout Standard
The OpenSHMEM library has been written to sit on top of any communications
 library that can provide the required functionalty.
 Initially we have targetted GASNet, and an ARMCI version is also planned.
 The 
\family typewriter
directory trunk/src/comms
\family default
 provides implementations of the internal API.
 All subsequent references to GASNet should be read with an eye on the abstracti
on process.
\end_layout

\begin_layout Subsection
Servicing Communications
\end_layout

\begin_layout Standard
GASNet provides this functionality.
 The mainline code needs to spin on variable waits (
\emph on
e.g.

\emph default
 shmem_long_waituntil) to poll GASNet, otherwise progress is automatic.
\end_layout

\begin_layout Subsection
Memory Management
\end_layout

\begin_layout Standard
Initially we tried to use the TLSF library:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://rtportal.upv.es/rtmalloc/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
but this proved to have weird interactions with Open-MPI.
 Tracking program progress with valgrind suggested that system memory calls
 were being intercepted.
\end_layout

\begin_layout Standard
So, following the Chapel lead,
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://chapel.cray.com/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
we now use the 
\begin_inset Quotes eld
\end_inset

dlmalloc
\begin_inset Quotes erd
\end_inset

 library
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://g.oswego.edu/dl/html/malloc.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to manage allocations in the symmetric memory space.
\end_layout

\begin_layout Subsection
Point-to-point routines
\end_layout

\begin_layout Standard
Point-to-point operations are a thin layer on top of GASNet.
 The non-blocking put operations with implicit handles provide a way to
 subsequently fence and barrier.
 However, tracking individual handles explicitly with a hash table keyed
 on the address of symmetric variables may give better performance.
\end_layout

\begin_layout Standard
The Quadrics extensions that add non-blocking calls into the API proper
 have already been requested for the OpenSHMEM development.
\end_layout

\begin_layout Subsection
Atomic Operations
\end_layout

\begin_layout Standard
Atomic operations include swaps, fetch-and-add and locks (discussed separately
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Locks"

\end_inset

).
 The first two are handled via GASNet's Active Messages.
 Increment was originally layered on top of add (increment = add 1, after
 all) but was rewritten with its own handlers.
 The payload for increment can be ever so slightly smaller than for add
 since there's no need to pass the value to add.
 In large applications, even such a small saving could add up (if you'll
 pardon the pun).
\end_layout

\begin_layout Standard
Eaarlier versions of the implementation had a single handler lock variable
 per operation (one for all adds, one for all increments, 
\emph on
etc.
\emph default
).
 However, we've now added a hash table to dynamically allocate and manage
 per-target-address handler locks.
 Large-scale atomic operations, like add-scatters across multiple variables
 could easily benefit from this, as the lock granularity then permits concurrent
 discrete memory accesses.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Locks"

\end_inset

Locks
\end_layout

\begin_layout Standard
OpenSHMEM provides routines to claim, release and test global locks.
 These can be used for mutual-exclusion regions.
 Our implementation is from the Quadrics library, which is a version of
 the Mellor-Crummy-Scott algorithm (
\begin_inset Quotes eld
\end_inset

Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors
\begin_inset Quotes erd
\end_inset

 by John M.
 Mellor-Crummey and Michael L Scott).
 The locks are layered on top of OpenSHMEM primitives, so there are no Elan
 dependencies.
\end_layout

\begin_layout Subsection
Barrier and broadcast
\end_layout

\begin_layout Standard
The initial version is naive, making the root of the broadcast a bottleneck.
 This is partly intentional, to allow Swaroop to explore better algorithms
 and work out how to demonstrate and document the improvements.
 We would like to collect some locality information inside the library to
 help decide communication order inside these algorithms: PEs that differ
 in rank by large amounts are likely to be further away topologically too,
 so by sending to more distant PEs first, we can stagger the network traffic
 and balance the latencies better.
 A proper measurement of 
\begin_inset Quotes eld
\end_inset

distance
\begin_inset Quotes erd
\end_inset

 is needed here.
 
\begin_inset Quotes eld
\end_inset

hwloc
\begin_inset Quotes erd
\end_inset

 provides a per-system distance metric in NUMA terms.
 A simple extension could 
\emph on
e.g.

\emph default
 just multiply the distance by some constant when moving off-node to penalize
 network traffic.
\end_layout

\begin_layout Subsection
Collects
\end_layout

\begin_layout Standard
The files 
\family typewriter
src/fcollect.c
\family default
 and 
\family typewriter
src/collect.c
\family default
 implement the collector routines (concatenating arrays on a set of PEs
 into a target array on all of those PEs).
\end_layout

\begin_layout Standard
fcollect is pretty easy since all the PEs must contribute the same amount
 of data.
 This means we can just pre-compute where each PE writes to their targets.
\end_layout

\begin_layout Standard
collect is harder because each PE can write different amounts.
 Thought of 2 ways of handling this:
\end_layout

\begin_layout Enumerate
initial exchange of sizes 
\begin_inset Quotes eld
\end_inset

from the left
\begin_inset Quotes erd
\end_inset

 so each PE can compute its write locations; then same as fcollect
\end_layout

\begin_layout Enumerate
wavefront: PEs wait for notification from PEs before them in the set (lower
 numbered).
 This passes the offsets across the set.
\end_layout

\begin_layout Standard
I used #2.
 #1 potentially generates a network storm as all PEs wait to work out where
 to write, then all write at once.
 #2 staggers the offset notification with a wave of writes moving up the
 PE numbers.
 
\end_layout

\begin_layout Subsection
Reductions
\end_layout

\begin_layout Standard
Reductions coalesce data from a number of PEs into either a single variable
 or array on all participating PEs.
 The coalescing involves some kind of arithmetic or logic operation (e.g.
 sum, product, exclusive-or).
 Currently probably naive, using gets.
 A version with puts that can overlap communication and the computation
 of the reduction operation should be more scalable.
 However, the code is rather compact and all ops use the same template.
 A future version of OpenSHMEM may add user-defined reductions.
\end_layout

\begin_layout Subsection
Address and PE Accessibility
\end_layout

\begin_layout Standard
OpenSHMEM allows us to test whether PEs are currently reachable, and whether
 addresses on remote PEs are addressable.
 GASNet is used to 
\begin_inset Quotes eld
\end_inset

ping
\begin_inset Quotes erd
\end_inset

 the remote PE and then we wait for an 
\begin_inset Quotes eld
\end_inset

ack
\begin_inset Quotes erd
\end_inset

 with a configurable timeout.
 Remains to be seen how useful this is, and whether it can be used for future
 fault tolerance issues.
\end_layout

\begin_layout Subsection
Tracing Facility
\end_layout

\begin_layout Standard
This library contains “trace points” with categorized messages.
 These are listed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Environment-Variables"

\end_inset


\end_layout

\begin_layout Standard
A high-resolution clock is maintained to timestamp such messages.
 Numerically sorting the output on the first field can thus help understand
 the order in which events happened.
\end_layout

\begin_layout Subsection
C++
\end_layout

\begin_layout Standard
The C++ interface is basically the C one.
 There is one point of contention, namely complex numbers.
 The SGI documentation refers only to the use of C99 
\begin_inset Quotes eld
\end_inset

complex
\begin_inset Quotes erd
\end_inset

 modifiers, not to C++'s 
\family typewriter
complex<T>
\family default
.
 The use of complex number routines (
\emph on
e.g.

\emph default
 reductions) in C++ is thus not clearly specified.
\end_layout

\begin_layout Subsection
Fortran
\end_layout

\begin_layout Standard
The Fortran interface is very similar to that of C.
 The names of various routines are different to accommodate the various
 type differences, e.g.
 
\family typewriter
shmem_integer_put()
\family default
 instead of 
\family typewriter
shmem_int_put()
\family default
.
\end_layout

\begin_layout Standard
The biggest difference is in the symmetric memory management routines.
 These have completely different names and parameters compared to the C
 interface.
\end_layout

\begin_layout Standard
The OpenSHMEM implementation handles Fortran with a very thin wrapper on
 top of C.
 Mostly this involves catching Fortran's pass-by-reference variables and
 dereferencing them in the underlying C call.
\end_layout

\begin_layout Standard
The main development has been on a CentOS platform with GNU 4.1.2-redhat.
 There seem to be some issues with this compilers' handling of cray-pointers:
 even the simplest programs (no OpenSHMEM content at all) produce a segmentation
 fault.
 Later versions (
\emph on
e.g.
 
\emph default
4.5.0 ++) behave better.
\end_layout

\begin_layout Section
Undefined Behavior
\end_layout

\begin_layout Standard
Many routines are currently specified only in terms of 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 behavior.
 What happens when something goes wrong is not always specified.
 This section attempts to set out a few of these scenarios
\end_layout

\begin_layout Itemize
put to PE out of range: suppose we do a put to 
\begin_inset Quotes eld
\end_inset

right neighbor
\begin_inset Quotes erd
\end_inset

 (pe + 1).
 The highest-numbered PE will attempt to communicate with a PE that does
 not exist.
\end_layout

\begin_layout Itemize
library not initialized: virtually all OpenSHMEM routines will have major
 problems if the library has not been initialized.
 Implementations can handle this situation in different ways.
\end_layout

\begin_layout Section
Environment Variables
\begin_inset CommandInset label
LatexCommand label
name "sec:Environment-Variables"

\end_inset


\end_layout

\begin_layout Standard
The behavior of the OpenSHMEM library can be controlled via a number of
 environment variables.
 For SGI compatibility reasons, we support the 
\begin_inset Quotes eld
\end_inset

SMA
\begin_inset Quotes erd
\end_inset

 variables and our own new ones:
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SMA_VERSION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
print the library version at start-up
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SMA_INFO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
print helpful text about all these environment variables
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SMA_SYMMETRIC_SIZE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
number of bytes to allocate for symmetric heap
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SMA_DEBUG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
enable debugging messages
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset

 
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_LOG_LEVELS
\family default
: a comma, space, or semi-colon separated list of logging/trace facilities
 to enable debugging messages.
 The facilities currently include the case-insensitive names:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Facility
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meaning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FATAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
something unrecoverable happened, abort
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DEBUG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
used for debugging purposes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INFO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
something interesting happened
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NOTICE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
important event, but non-fatal (see below)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AUTH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when something is attempted but not allowed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INIT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
set-up and tear-down of the program
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MEMORY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
symmetric memory information
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CACHE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cache flushing operations
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BARRIER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
about barrier operations
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BROADCAST
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
about broadcast operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
COLLECT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
about collect and fcollect operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
REDUCE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
about reduction operations
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SYMBOLS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
to inspect the symbol table information
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOCK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
related to setting, testing and clearing locks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SERVICE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
related to the network service thread
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FENCE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tracing network fence events
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
QUIET
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tracing network quiet events
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_LOG_FILE
\family default
: a filename to which to write log messages.
 All PEs append to this file.
 The default is for all PEs to write to standard error.
 Per-PE log files might be an interesting addition.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_SYMMETRIC_HEAP_SIZE
\family default
: the number of bytes to allocate for the symmetric heap area.
 Can scale units with 
\begin_inset Quotes eld
\end_inset

K
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

M
\begin_inset Quotes erd
\end_inset

 etc.
 modifiers.
 The default is 1M.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_BARRIER_ALGORITHM
\family default
: the version of the barrier to use.
 The default is 
\begin_inset Quotes eld
\end_inset

naive
\begin_inset Quotes erd
\end_inset

.
 Designed to allow people to plug other variants in easily and test.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_BARRIER_ALL_ALGORITHM
\family default
: as for 
\family typewriter
SHMEM_BARRIER_ALGORITHM
\family default
, but separating these two allows us to optimize if e.g.
 hardware has special support for global barriers.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
SHMEM_PE_ACCESSIBLE_TIMEOUT
\family default
: the number of seconds to wait for PEs to reply to accessiblity checks.
 The default is 1.0 (i.e may be fractional).
\end_layout

\begin_layout Section
Compiling and Running Programs
\end_layout

\begin_layout Standard
The SGI SHMEM is provided as part of the Message-Passing Toolkit (MPT) in
 the 
\begin_inset CommandInset href
LatexCommand href
name "ProPack"
target "http://www.sgi.com/products/software/propack.html"

\end_inset

 suite.
 Compilation uses a standard C, C++ or Fortran compiler (
\emph on
e.g.

\emph default
 GNU, Intel) and links against the SMA and MPI libraries.
\end_layout

\begin_layout Standard
In order to abstract the compilation and launching process for OpenSHMEM
 we have provided 4 wrapper programs:
\end_layout

\begin_layout Enumerate

\family typewriter
oshcc
\family default
: for compiling and linking C programs.
\end_layout

\begin_layout Enumerate

\family typewriter
oshCC
\family default
: for compiling and linking C++ programs.
\end_layout

\begin_layout Enumerate

\family typewriter
oshfort
\family default
: for compiling and linking F77/F90 programs.
\end_layout

\begin_layout Enumerate

\family typewriter
oshrun
\family default
: to launch programs.
\end_layout

\begin_layout Standard
The similarity to the style of wrappers found in many MPI implementations
 is obvious and intentional.
 Currently these wrappers do handle a few situations (e.g.
 oshcc/CC and oshfort detect that they shouldn't do linking and stop the
 underlying compiler complaining about link options being present, but unused).
 The compiler scripts are generated from a common template.
\end_layout

\begin_layout Standard
The run wrapper currently detects which GASNet conduit is being used and
 sets up the environment accordingly to launch the program.
 Not sure if this is the best place to do this check, or if the build process
 should work this out in advance to streamline the installed code.
\end_layout

\begin_layout Section
Configuration and Installation
\end_layout

\begin_layout Standard
There is a 
\family typewriter
trunk/configure
\family default
 script that is a simplified version of the GNU autotools.
 This script will eventually become the GNU setup and will do lots more
 feature tests.
 So the usual procedure applies: configure, make, make install.
\end_layout

\begin_layout Section
Future Plans
\end_layout

\begin_layout Standard
Ideas for extensions to SHMEM to go into OpenSHMEM need to be requested
 and evaluated from the SHMEM user and vendor community.
 A decision process will determine which ideas are eventually implemented.
 The library that this document refers to is hopefully a good platform for
 these developments.
\end_layout

\begin_layout Standard
A number of extensions have already been proposed, and in fact have been
 implemented in other SHMEM libraries.
 These include (but are not limited to)
\end_layout

\begin_layout Itemize
thread-safety: providing thread-safe SHMEM routines that can operate in
 threaded environments, 
\emph on
e.g.

\emph default
 alongside OpenMP;
\end_layout

\begin_layout Itemize
non-blocking puts: put routines that return per-communication handles to
 the caller.
 The handles can be tested later for completion (present in Cray and Quadrics
 SHMEMs); this extension may require revamping the way implicit handles
 are used in GASNet, since we will be generating calls with explicitly generated
 handles.
 Building a handle pool on which to synchronize later should take care of
 this.
\end_layout

\begin_layout Itemize
locality: exposing information about topology to the library and/or its
 API;
\end_layout

\begin_layout Itemize
regularized namespace: currently routines are a strange brew of 
\begin_inset Quotes eld
\end_inset

shmem_
\begin_inset Quotes erd
\end_inset

 prefixes, 
\begin_inset Quotes eld
\end_inset

start_pes
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

_my_pe
\begin_inset Quotes erd
\end_inset

 and so on.
 Providing an API with a consistent naming scheme would be useful;
\end_layout

\begin_layout Itemize
Fortran module, C++ API: provide better language support.
\end_layout

\end_body
\end_document
