      Benchmark #10  --  N-Queens  (SHMEM version)

Count the number of ways N queens can be placed on an N x N
chessboard so that no queen can attack another, i.e., no 
two queens are on the same row, column, or diagonal.

Compute the number of such configurations and for each
configuration save the positions of the queens.

Output the number of solutions and those positions that
are selected by the output routine.

Despite the fact that obvious symmetries exist on the 
chessboard they are to be ignored in this problem.  The 
suggested approach is that of tree searching.

Call time parameters:

   N    =  The size of the chess board.
               Minimum allowed = 4
               Maximum = Default = 16 

   WIDTH = The degree of parallelism, the number of branches being
           searched at any one time.
               Max allowed = 1024
               Default = 128

   SLVL  = The number of levels of the tree to search before dividing
           the resulting near-root nodes among processors.
               Minimum allowed = 2
               Maximum allowed = 5
               Default = 3

The default values for WIDTH and SLVL are near optimal for the larger
values of N.  However, they can result in very poor performance for 
the smaller values of N.  For example, for N = 8, a 2x speedup has
been observed using SLVL = 2.  For the larger values of N, some 
slight improvement has been observed using SLVL = 4.

Not all combinations of these parameters have been tested, and some 
may core dump.  Others (particularly for N = 16) may have an overflow 
in the space alloted to hold solutions for each processor.  However 
the default parameters have been verified for all N > 7.
 
Command line: m10 [N [WIDTH [sLVL]]]

The makefile for benchmark 10 requires the ".c" files: m10, p10, c10, r10 and
util. All the ".c" files except "util.c" require the header
definition file "b10defs.h".

       make  -        will provide the basic benchmark m10

       make clean   - will remove all *.o, *.V and core files


Note:
	This is the SHMEM parallelized version of the above benchmark.
	Please note that every effort has been made to make this bench-
	mark identicial to the "single.cpu" original benchmark.  So,
	taking that into consideration, notice the following two items:
	
		- Only the actual computation of the solutions is
		  parallelized.  Checking of all of the solutions
		  is done by a single (the master) CPU.  Consequently,
		  this benchmark returns accurate measure of not only
		  the efficiency of the interconnection network and
		  the processing power of the separate CPUs, but also
		  it gives statistics of the processing power of a single
		  (the master) CPU.

		- The algorithm followed by the "single.cpu" benchmark
		  is embarassingly parallel.  Therefore, this algorithm
		  is also embarassingly parallel were all of the sub-trees
		  are split "evenly" between the processors.  Processors
		  which finish early are not reused or reassigned.  This
		  is the only significant difference between the "single.cpu"
		  version and this version.
