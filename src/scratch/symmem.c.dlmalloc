#include <assert.h>
#include <sys/types.h>

#include "gasnet_safe.h"

#include "state.h"
#include "barrier.h"
#include "warn.h"

#include "shmem.h"

typedef void *mspace;
extern mspace create_mspace_with_base(void* base, size_t capacity, int locked);
extern void * mspace_malloc(mspace msp, size_t bytes);
extern void mspace_free(mspace msp, void *mem);

static mspace myspace;

/*
 * Tony's development interface
 */

static gasnet_seginfo_t* seginfo_table;

void
__symmetric_memory_init(void)
{
  seginfo_table = (gasnet_seginfo_t *)calloc(__state.numpes,
                                             sizeof(gasnet_seginfo_t));
  assert(seginfo_table != (gasnet_seginfo_t *)NULL);

  GASNET_SAFE( gasnet_getSegmentInfo(seginfo_table, __state.numpes) );

  __gasnet_barrier_all();

  /*
   * each PE initializes its own table, but can see addresses of all PEs
   */
  myspace = create_mspace_with_base(seginfo_table[__state.mype].addr,
                                    seginfo_table[__state.mype].size,
                                    1
                                   );

  __gasnet_barrier_all();
}

/*
 * where the symmetric memory starts on the given PE
 */
void *
__symmetric_var_base(int pe)
{
  return myspace + 128;
}

/*
 * is the address in the managed symmetric area?
 */
int
__symmetric_var_in_range(void *addr, int pe)
{
  void *top = myspace + seginfo_table[pe].size;
  return (myspace <= addr) && (addr < top) ? 1 : 0;
}

/*
 * PUBLIC INTERFACE
 */

long malloc_error = 0;         /* exposed for error codes */

const long SHMEM_MALLOC_OK=0L;
const long SHMEM_MALLOC_FAIL=1L;
const long SHMEM_MALLOC_ALREADY_FREE=2L;

void *
shmalloc(size_t size)
{
  void *area = __symmetric_var_base(__state.mype);
  void *addr;

  addr = mspace_malloc(area, size);

  if (addr == (void *)NULL) {
    __shmem_warn("NOTICE", "shmalloc(%ld) failed\n", size);
    malloc_error = SHMEM_MALLOC_FAIL;
  }

__shmem_warn("INFO", "allocating %ld @ %p", size, addr);

  return addr;
}

void
shfree(void *addr)
{
  void *area = __symmetric_var_base(__state.mype);

  if (addr == (void *)NULL) {
    __shmem_warn("NOTICE", "shfree(%p) already null\n", addr);
    malloc_error = SHMEM_MALLOC_ALREADY_FREE;
    return;
  }

__shmem_warn("INFO", "freeing @ %p", addr);

  // TODO: sometimes causes segfaults...
  // mspace_free(area, addr);

  malloc_error = 0;
}

/*
 * TODO: shrealloc
 */
void *
shrealloc(void *ptr, size_t size)
{
  return (void *)NULL;
}

/*
 * TODO: shmemalign
 */
void *
shmemalign(size_t alignment, size_t size)
{
  return (void *)NULL;
}
